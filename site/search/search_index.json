{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ODBC-GAN: An integrated GAN model for outlier detection and batch correction in multi-sample and multi-modal transcriptomics","text":"<p>We propose a Generative Adversarial Networks called ODBC-GAN  (Outlier Detection and Batch Correction GAN), which can detect different types of outlier observations (cells or spots), detect the subtypes of outliers further, and correct batch effects among multi-sample datasets. ODBC-GAN has two main modes (SC and SRT), which can be suitable for single-cell or spatially resolved transcriptomics dataset. ODBC-GAN in SC mode can solve these problem by gene expression of cells, and SRT mode combines gene expression, position information, and slice image of spots.</p> <p></p> <p></p>"},{"location":"#applicable-tasks","title":"Applicable tasks","text":""},{"location":"#outlier-detection","title":"Outlier detection","text":"<ul> <li>Detect outlier cells on single-cell datasets.</li> <li>Classify subtypes of the outlier cells.</li> <li>Detect outlier spots on spatial transcriptomics datasets.</li> <li>Classify subtypes of the outlier spots.</li> </ul>"},{"location":"#batch-correction","title":"Batch correction","text":"<ul> <li>Correct the batch effects among single-cell datasets.</li> <li>Correct the batch effects among vertical slice spatial transcriptomics datasets.</li> <li>Correct the batch effects among horizontal slice spatial transcriptomics datasets.</li> </ul>"},{"location":"#advantages","title":"Advantages","text":"<ul> <li>Superior performance.</li> <li>Integrated outlier detection and batch correction in multi-sample transcriptomic data.</li> <li>Avoid negative values after batch correction.</li> <li>Keep the original data space after batch correction.</li> <li>Applicability to both scRNA-seq and SRT.</li> </ul>"},{"location":"#tested-environment","title":"Tested environment","text":"<ul> <li>CPU: Intel(R) Xeon(R) Platinum 8255C CPU @ 2.50GHz</li> <li>CPU Memory: 256 GB</li> <li>GPU: NVIDIA GeForce RTX 3090</li> <li>GPU Memory: 24 GB</li> <li>System: Ubuntu 20.04.5 LTS</li> <li>Python: 3.9.15</li> </ul>"},{"location":"#source-codes","title":"Source codes","text":"<p>All the source codes of ODBC-GAN are available on ODBC-GAN.</p>"},{"location":"#contributors","title":"Contributors","text":"<ul> <li>Kaichen Xu: lead developer, initial ODBC-GAN conception.</li> <li>Kainan Liu: developer, diverse contributions.</li> <li>Xiaobo Sun &amp; lab: enabling guidance, support and environment.</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>Coming soon.</p>"},{"location":"API/API_overview/","title":"API","text":"<p>Start the API documentation as:</p> <pre><code>import ODBCGAN as og\n</code></pre>"},{"location":"API/API_overview/#main-functions","title":"Main functions","text":"<p>ODBC-GAN has integrated different API to some main functions. These main functions can be used straightforward for implementing outlier detection, batch correction and subtype detection by one-step.</p> API Description og.outlier_detect(mode='SC') Detect outlier cells og.outlier_detect(mode='SRT') Detect outlier spots og.subtype_detect(mode='SC') Detect subtypes of outlier cells og.subtype_detect(mode='SRT') Detect subtypes of outlier spots og.obs_align(mode='SC') Find cell pairs among SC data og.obs_align(mode='SRT', slice='Vertical') Find spot pairs among SRT (vertical) data og.obs_align(mode='SRT', slice='Horizontal') Find spot pairs among SRT (horizontal) data og.batch_correct(mode='SC') Correct batch effects among SC data og.batch_correct(mode='SRT', slice='Vertical') Correct batch effects among SRT (vertical) data og.batch_correct(mode='SRT', slice='Horizontal') Correct batch effects among SRT (horizontal) data"},{"location":"API/Align/Align_SC/","title":"og.align.Align_SC","text":"<p>Class</p> <p>og.align.Align_SC(n_epochs=1000, learning_rate=1e-3, pretrain=True, GPU=True, verbose=True, log_interval=200, weight=None, random_state=100, fast=False)</p> <p>Find cell pairs with gene expression as SC mode of ODBC-GAN.</p> <p>og.align.Align_SC has two important functions fit and fit_mult. This class has been integrated in og.obs_align as SC mode.</p> <p>Parameters:</p> <ul> <li> <p>n_epochs: <code>int</code> (default: <code>1000</code>)</p> <p>Number of train epochs.</p> </li> <li> <p>learning_rate: <code>float</code> (default: <code>1e-3</code>)</p> <p>Learning rate for Adam optim.</p> </li> <li> <p>pretrain: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, load pretrained weight for ODBC-GAN.</p> </li> <li> <p>GPU: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, run ODBC-GAN on GPU.</p> </li> <li> <p>verbose: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, print detailed information of every epoch.</p> </li> <li> <p>log_interval: <code>int</code> (default: <code>200</code>)</p> <p>Interval of epochs between two adjacent printed information.</p> </li> <li> <p>weight: <code>Optional[Dict]</code> (default: <code>None</code>)</p> <p>Weight for every part of loss. If <code>None</code>, <code>weight</code> should be set as <code>{'w_rec': 50, 'w_adv': 1, 'w_gp': 10}</code>.</p> </li> <li> <p>random_state: <code>Optional[int]</code> (default: <code>100</code>)</p> <p>Random state to control all kinds of random seeds.</p> </li> <li> <p>fast: <code>bool</code> (default: <code>False</code>)</p> <p>If <code>True</code>, fast mode will be used.</p> </li> </ul> <p>Function of og.align.Align_SC</p> <p>fit(input, reference, log=True)</p> <p>Find cell pairs between two batches.</p> <p>Parameters:</p> <ul> <li> <p>input: <code>anndata.AnnData</code></p> <p>Input adata of shape <code>n_obs</code> \u00d7 <code>n_vars</code>. Rows correspond to cells and columns to genes.</p> </li> <li> <p>reference: <code>anndata.AnnData</code></p> <p>Reference adata of shape <code>n_obs</code> \u00d7 <code>n_vars</code>. Rows correspond to cells and columns to genes.</p> </li> <li> <p>log: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, print the loggers.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>idx: <code>pandas.DataFrame</code></p> <p>Results of observations alignment. Every column contains <code>obs_names</code> in reference data and input data. Every row means the observation pairs among reference data and input data.</p> </li> </ul> <p>Function of og.align.Align_SC</p> <p>fit(input, reference)</p> <p>Find cell pairs among multiple batches.</p> <p>Parameters:</p> <ul> <li> <p>input: <code>List[anndata.AnnData]</code></p> <p>List of input adata. Every adata has the same genes.</p> </li> <li> <p>reference: <code>anndata.AnnData</code></p> <p>Reference adata of shape <code>n_obs</code> \u00d7 <code>n_vars</code>. Rows correspond to cells and columns to genes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>idx: <code>pandas.DataFrame</code></p> <p>Results of observations alignment. Every column contains <code>obs_names</code> in reference data and input data. Every row means the observation pairs among reference data and input data.</p> </li> </ul> <p>Warning</p> <p><code>input</code> and <code>reference</code> should have the same genes.</p>"},{"location":"API/Align/Align_SRT/","title":"og.align.Align_SRT","text":"<p>Class</p> <p>og.align.Align_SRT(n_epochs=1500, learning_rate=1e-4, pretrain=True, GPU=True, verbose=True, log_interval=300, weight=None, random_state=100, fast=False, slice='Vertical', patch_size=48)</p> <p>Find spot pairs with gene expression, position and slice image as SRT mode of ODBC-GAN.</p> <p>og.align.Align_SRT has two important functions fit and fit_mult. This class has been integrated in og.obs_align as SRT mode.</p> <p>Parameters:</p> <ul> <li> <p>n_epochs: <code>int</code> (default: <code>1500</code>)</p> <p>Number of train epochs.</p> </li> <li> <p>learning_rate: <code>float</code> (default: <code>1e-4</code>)</p> <p>Learning rate for Adam optim.</p> </li> <li> <p>pretrain: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, load pretrained weight for ODBC-GAN.</p> </li> <li> <p>GPU: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, run ODBC-GAN on GPU.</p> </li> <li> <p>verbose: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, print detailed information of every epoch.</p> </li> <li> <p>log_interval: <code>int</code> (default: <code>300</code>)</p> <p>Interval of epochs between two adjacent printed information.</p> </li> <li> <p>weight: <code>Optional[Dict]</code> (default: <code>None</code>)</p> <p>Weight for every part of loss. If <code>None</code>, <code>weight</code> should be set as <code>{'w_rec': 50, 'w_adv': 1, 'w_gp': 10}</code>.</p> </li> <li> <p>random_state: <code>Optional[int]</code> (default: <code>100</code>)</p> <p>Random state to control all kinds of random seeds.</p> </li> <li> <p>fast: <code>bool</code> (default: <code>False</code>)</p> <p>If <code>True</code>, fast mode will be used.</p> </li> <li> <p>slice: <code>Literal['Vertical', 'Horizontal']</code> (default: <code>'Vertical'</code>)</p> <p>Slice type of SRT data.</p> </li> <li> <p>patch_size: <code>int</code> (default: <code>48</code>)</p> <p>Side length of every patch.</p> </li> </ul> <p>Function of og.align.Align_SRT</p> <p>fit(input, reference, input_image, ref_image, log=True)</p> <p>Find spot pairs between two batches.</p> <p>Parameters:</p> <ul> <li> <p>input: <code>anndata.AnnData</code></p> <p>Input adata of shape <code>n_obs</code> \u00d7 <code>n_vars</code>. Rows correspond to cells and columns to genes.</p> </li> <li> <p>reference: <code>anndata.AnnData</code></p> <p>Reference adata of shape <code>n_obs</code> \u00d7 <code>n_vars</code>. Rows correspond to cells and columns to genes.</p> </li> <li> <p>input_image: <code>numpy.ndarray</code></p> <p>Input H&amp;E image.</p> </li> <li> <p>ref_image: <code>numpy.ndarray</code></p> <p>Reference H&amp;E image for reference data.</p> </li> <li> <p>log: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, print the loggers.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>idx: <code>pandas.DataFrame</code></p> <p>Results of observations alignment. Every column contains <code>obs_names</code> in reference data and input data. Every row means the observation pairs among reference data and input data.</p> </li> </ul> <p>Function of og.align.Align_SRT</p> <p>fit(input, reference, input_image, ref_image)</p> <p>Find spot pairs among multiple batches.</p> <p>Parameters:</p> <ul> <li> <p>input: <code>List[anndata.AnnData]</code></p> <p>List of input adata. Every adata has the same genes.</p> </li> <li> <p>reference: <code>anndata.AnnData</code></p> <p>Reference adata of shape <code>n_obs</code> \u00d7 <code>n_vars</code>. Rows correspond to cells and columns to genes.</p> </li> <li> <p>input_image: <code>List[numpy.ndarray]</code></p> <p>List of input H&amp;E images.</p> </li> <li> <p>ref_image: <code>numpy.ndarray</code></p> <p>Reference H&amp;E image for reference data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>idx: <code>pandas.DataFrame</code></p> <p>Results of observations alignment. Every column contains <code>obs_names</code> in reference data and input data. Every row means the observation pairs among reference data and input data.</p> </li> </ul> <p>Warning</p> <ul> <li><code>input</code> and <code>reference</code> should have the same genes.</li> <li><code>input_image</code> and <code>ref_image</code> are required. And the position of every spot on image should contain in <code>input.obsm['spatial']</code> and <code>ref.obsm['spatial']</code>.</li> <li>Every object in <code>input</code> and <code>input_image</code> should be matched.</li> <li>When <code>'slice='Vertical'</code> and <code>slice='Horizontal'</code>, different hyperparameters may be used.</li> </ul>"},{"location":"API/Align/obs_align/","title":"og.obs_align","text":"<p>Function</p> <p>og.obs_align(input, reference, input_image=None, ref_image=None, mode='SC', slice=None)</p> <p>Find cell pairs in SC mode, and spot pairs in SRT mode.</p> <p>Integrate two main classes og.align.Align_SC and og.align.Align_SRT to implement observations alignment.</p> <p>Hyperparameters (<code>n_epochs</code>, <code>learning_rate</code>, and etc.) are allowed for changing the default configuration. Detailed hyperparameter description can be see in og.align.Align_SC and og.align.Align_SRT.</p> <p>Parameters:</p> <ul> <li> <p>input: <code>Union[anndata.AnnData, List[anndata.AnnData]]</code></p> <p>Input adata or list of input adata. Every adata has the same genes.</p> </li> <li> <p>reference: <code>anndata.AnnData</code></p> <p>Reference data of shape <code>n_obs</code> \u00d7 <code>n_vars</code>. Rows correspond to cells and columns to genes.</p> </li> <li> <p>input_image: <code>Optional[Union[numpy.ndarray, List[numpy.ndarray]]]</code> (default=<code>None</code>)</p> <p>Input H&amp;E image or list of input H&amp;E images.</p> </li> <li> <p>ref_image: <code>Optional[numpy.ndarray]</code> (default=<code>None</code>)</p> <p>Reference H&amp;E image for reference data.</p> </li> <li> <p>mode: <code>Literal['SC', 'SRT']</code> (default: <code>'SC'</code>)</p> <p>Working mode of ODBC-GAN. </p> </li> <li> <p>slice: <code>Optional[Literal['Vertical', 'Horizontal']]</code> (default: <code>None</code>)</p> <p>Slice type of SRT data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>idx: <code>pandas.DataFrame</code></p> <p>Results of observations alignment. Every column contains <code>obs_names</code> in reference data and input data. Every row means the observation pairs among reference data and input data.</p> </li> </ul> <p>Warning</p> <ul> <li><code>input</code> and <code>reference</code> should have the same genes.</li> <li>In SRT mode, <code>input_image</code> and <code>ref_image</code> are required. And the position of every spot on image should contain in <code>input.obsm['spatial']</code> and <code>ref.obsm['spatial']</code>.</li> <li>In SRT mode, every object in <code>input</code> and <code>input_image</code> should be matched.</li> </ul> <p>Example: <pre><code>import scanpy as sc\nimport ODBCGAN as og\nadata1 = sc.read('adata1.h5ad')  # reference data\nadata2 = sc.read('adata2.h5ad')\nadata3 = sc.read('adata3.h5ad')\n# two batch\nog.obs_align(adata2, adata1, mode='SC')\n# multi-batch\nog.obs_align([adata2, adata3], adata1, mode='SC')\n# fast mode\nog.obs_align(adata2, adata1, mode='SC', fast=True)\n# tune hyperparameters\nog.obs_align(adata2, adata1, mode='SC', learning_rate=1e-4)\n</code></pre></p>"},{"location":"API/Dataset/Build_graph/","title":"og._dataset.Build_graph","text":"<p>Class</p> <p>og._dataset.Build_graph(adata, image, n_neighbors=3, patch_size=48, train_mode=True)</p> <p>Build a graph for spatial transcriptomics data by dgl.</p> <p>Graph is contained in attribute <code>g</code>.</p> <p>Parameters:</p> <ul> <li> <p>adata: <code>anndata.AnnData</code></p> <p>Input data of shape <code>n_obs</code> \u00d7 <code>n_vars</code>. Rows correspond to cells and columns to genes. Position information is contained in <code>adata.obsm['spatial']</code>.</p> </li> <li> <p>image: <code>numpy.ndarray</code></p> <p>H&amp;E image of input data.</p> </li> <li> <p>n_neighbors: <code>int</code> (default: <code>3</code>)</p> <p>Number of neighbors to generate adjacency matrix.</p> </li> <li> <p>patch_size: <code>int</code> (default: <code>48</code>)</p> <p>Side length of every patch.</p> </li> <li> <p>train_mode: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, patches will pass through color jitter, random horizontal flip, and random rotation.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <p>g: <code>dgl.Graph</code></p> <p>Graph object built.</p> <p>Nodes are the observations in <code>adata</code>.</p> <p>Edges indicate how close the two observations' positions are.</p> <p><code>g.ndata['patch']</code>, image patch of every spot.</p> <p><code>g.ndata['x']</code>, gene expression vector of every spot.</p> <p><code>g.ndata['position']</code>, position of every spot.</p> </li> </ul> <p>Note</p> <p>If in pre-training, <code>train_mode=True</code> can provide data augmentation to train your model.</p> <p>Example: <pre><code>import ODBCGAN as og\nbuilder = og._dataset.Build_graph(adata, image)\ng = builder.g\n</code></pre></p>"},{"location":"API/Dataset/Build_multi_graph/","title":"og._dataset.Build_multi_graph","text":"<p>Class</p> <p>og._dataset.Build_multi_graph(adata, image, n_neighbors=3, patch_size=48, train_mode=True)</p> <p>Build a graph for multi-sample spatial transcriptomics data by dgl.</p> <p>Graph is contained in attribute <code>g</code>.</p> <p>Parameters:</p> <ul> <li> <p>adata: <code>List[anndata.AnnData]</code></p> <p>List of input adata. Every adata has the same genes.</p> </li> <li> <p>image: <code>List[numpy.ndarray]</code></p> <p>List of input H&amp;E images.</p> </li> <li> <p>n_neighbors: <code>int</code> (default: <code>3</code>)</p> <p>Number of neighbors to generate adjacency matrix.</p> </li> <li> <p>patch_size: <code>int</code> (default: <code>48</code>)</p> <p>Side length of every patch.</p> </li> <li> <p>train_mode: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, patches will pass through color jitter, random horizontal flip, and random rotation.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <p>g: <code>dgl.Graph</code></p> <p>Graph object built.</p> <p>Nodes are the observations in <code>adata</code>.</p> <p>Edges indicate how close the two observations' positions are.</p> <p><code>g.ndata['patch']</code>, image patch of every spot.</p> <p><code>g.ndata['x']</code>, gene expression vector of every spot.</p> <p><code>g.ndata['position']</code>, position of every spot.</p> </li> </ul> <p>Note</p> <p>If in pre-training, <code>train_mode=True</code> can provide data augmentation to train your model.</p> <p>Warning</p> <p>Every object in <code>adata</code> and <code>image</code> should be matched.</p> <p>Example: <pre><code>import ODBCGAN as og\nadata = [adata1, adata2, adata3]\nimage = [image1, image2, image3]\nbuilder = og._dataset.Build_multi_graph(adata, image)\ng = builder.g\n</code></pre></p>"},{"location":"API/Outlier/Detect_SC/","title":"og.detect.Detect_SC","text":"<p>Class</p> <p>og.detect.Detect_SC(n_epochs=400, learning_rate=3e-4, sample_rate=1, mem_dim=1024, update_size=64, shrink_thres=9e-3, temperature=1, n_critic=2, pretrain=True, GPU=True, verbose=True, log_interval=100, random_state=100, weight=None)</p> <p>Detect outlier cells with gene expression as SC mode of ODBC-GAN.</p> <p>og.detect.Detect_SC has two important functions fit and predict. This class has been integrated in og.outlier_detect as SC mode.</p> <p>Parameters:</p> <ul> <li> <p>n_epochs: <code>int</code> (default: <code>400</code>)</p> <p>Number of train epochs.</p> </li> <li> <p>learning_rate: <code>float</code> (default: <code>3e-4</code>)</p> <p>Learning rate for Adam optim.</p> </li> <li> <p>sample_rate: <code>float</code> (default: <code>1</code>)</p> <p>Proportion of the actual train data to the input train data. Consider taking a smaller <code>sample_rare</code> when input train data is large-scale.</p> </li> <li> <p>mem_dim: <code>float</code> (default: <code>1024</code>)</p> <p>Number of embeddings stored in the memory bank. Larger <code>mem_dim</code> doesn't always mean better results, which means ODBC-GAN is insensitive to the size of memory bank.</p> </li> <li> <p>update_size: <code>int</code> (default: <code>64</code>)</p> <p>Number of embeddings updated in every epoch.</p> </li> <li> <p>shrink_thres: <code>float</code> (default: <code>9e-3</code>)</p> <p>Shrinkage threshold for attention score in the memory unit.</p> </li> <li> <p>temperature: <code>float</code> (default: <code>1</code>)</p> <p>Temperature hyperparameter for attention score in the memory unit.</p> </li> <li> <p>n_critic: <code>int</code> (default: <code>2</code>)</p> <p>Number of times the discriminator is updated in a epoch. Moreover, generator is only updated once in a epoch.</p> </li> <li> <p>pretrain: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, load pretrained weight for ODBC-GAN.</p> </li> <li> <p>GPU: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, run ODBC-GAN on GPU.</p> </li> <li> <p>verbose: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, print detailed information of every epoch.</p> </li> <li> <p>log_interval: <code>int</code> (default: <code>100</code>)</p> <p>Interval of epochs between two adjacent printed information.</p> </li> <li> <p>random_state: <code>Optional[int]</code> (default: <code>100</code>)</p> <p>Random state to control all kinds of random seeds.</p> </li> <li> <p>weight: <code>Optional[Dict]</code> (default: <code>None</code>)</p> <p>Weight for every part of loss. If <code>None</code>, <code>weight</code> should be set as <code>{'w_rec': 50, 'w_adv': 1, 'w_enc': 1, 'w_gp': 10}</code>.</p> </li> </ul> <p>Function of og.detect.Detect_SC</p> <p>fit(train)</p> <p>Learn information of normal cells on train data by full-batch.</p> <p>Parameters:</p> <ul> <li> <p>train: <code>anndata.AnnData</code></p> <p>Train data of shape <code>n_obs</code> \u00d7 <code>n_vars</code>. Rows correspond to cells and columns to genes.</p> </li> </ul> <p>Function of og.detect.Detect_SC</p> <p>predict(test)</p> <p>Detect outlier cells on test data by full-batch.</p> <p>Parameters:</p> <ul> <li> <p>test: <code>anndata.AnnData</code></p> <p>Test data of shape <code>n_obs</code> \u00d7 <code>n_vars</code>. Rows correspond to cells and columns to genes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>result: <code>pandas.DataFrame</code></p> <p>Results of outlier detection. <code>result['cell_idx']</code> contains <code>test.obs_names</code>, and <code>result['score']</code> contains the anomaly scores of every observation. </p> </li> </ul> <p>Warning</p> <ul> <li>fit must be run before predict.</li> <li><code>train</code> and <code>test</code> should have the same genes.</li> </ul>"},{"location":"API/Outlier/Detect_SRT/","title":"og.detect.Detect_SRT","text":"<p>Class</p> <p>og.detect.Detect_SRT(n_epochs=2, learning_rate=7e-6, sample_rate=1, mem_dim=1024, update_size=64, shrink_thres=0.5, temperature=3, n_critic=1, pretrain=True, GPU=True, verbose=True, log_interval=100, random_state=100, weight=None, batch_size=64, patch_size=48, MultiResSkips=True)</p> <p>Detect outlier spots with gene expression, position and image as SRT mode of ODBC-GAN.</p> <p>og.detect.Detect_SRT has two important functions fit and predict. This class has been integrated in og.outlier_detect as SRT mode.</p> <p>Parameters:</p> <ul> <li> <p>n_epochs: <code>int</code> (default: <code>2</code>)</p> <p>Number of train epochs.</p> </li> <li> <p>learning_rate: <code>float</code> (default: <code>7e-6</code>)</p> <p>Learning rate for Adam optim.</p> </li> <li> <p>sample_rate: <code>float</code> (default: <code>1</code>)</p> <p>Proportion of the actual train data to the input train data. Consider taking a smaller <code>sample_rare</code> when input train data is large-scale.</p> </li> <li> <p>mem_dim: <code>float</code> (default: <code>1024</code>)</p> <p>Number of embeddings stored in the memory bank. Larger <code>mem_dim</code> doesn't always mean better results, which means ODBC-GAN is insensitive to the size of memory bank.</p> </li> <li> <p>update_size: <code>int</code> (default: <code>64</code>)</p> <p>Number of embeddings updated in every epoch.</p> </li> <li> <p>shrink_thres: <code>float</code> (default: <code>0.5</code>)</p> <p>Shrinkage threshold for attention score in the memory unit.</p> </li> <li> <p>temperature: <code>float</code> (default: <code>3</code>)</p> <p>Temperature hyperparameter for attention score in the memory unit.</p> </li> <li> <p>n_critic: <code>int</code> (default: <code>1</code>)</p> <p>Number of times the discriminator is updated in a epoch. Moreover, generator is only updated once in a epoch.</p> </li> <li> <p>pretrain: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, load pretrained weight for ODBC-GAN.</p> </li> <li> <p>GPU: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, run ODBC-GAN on GPU.</p> </li> <li> <p>verbose: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, print detailed information of every epoch.</p> </li> <li> <p>log_interval: <code>int</code> (default: <code>100</code>)</p> <p>Interval of epochs between two adjacent printed information.</p> </li> <li> <p>random_state: <code>Optional[int]</code> (default: <code>100</code>)</p> <p>Random state to control all kinds of random seeds.</p> </li> <li> <p>weight: <code>Optional[Dict]</code> (default: <code>None</code>)</p> <p>Weight for every part of loss. If <code>None</code>, <code>weight</code> should be set as <code>{'w_rec': 50, 'w_adv': 1, 'w_enc': 1, 'w_gp': 10}</code>.</p> </li> <li> <p>batch_size: <code>int</code> (default: <code>64</code>)</p> <p>Batch size of train data.</p> </li> <li> <p>patch_size: <code>int</code> (default: <code>48</code>)</p> <p>Side length of every patch.</p> </li> <li> <p>MultiResSkips: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, use Multi-Residual-Block Skips in image generator.</p> </li> </ul> <p>Function of og.detect.Detect_SRT</p> <p>fit(train, image)</p> <p>Learn information of normal spots on train data by mini-batch.</p> <p>Full graph of train data is generated by og._dataset.Build_graph.</p> <p>Every batch is a subgraph on the full graph, provided by dgl.dataloading.DataLoader.</p> <p>Parameters:</p> <ul> <li> <p>train: <code>anndata.AnnData</code></p> <p>Train data of shape <code>n_obs</code> \u00d7 <code>n_vars</code>. Rows correspond to cells and columns to genes.</p> </li> <li> <p>image: <code>numpy.ndarray</code></p> <p>H&amp;E image of train data.</p> </li> </ul> <p>Function of og.detect.Detect_SRT</p> <p>predict(test, image)</p> <p>Detect outlier spots on test data by mini-batch.</p> <p>Full graph of test data is generated by og._dataset.Build_graph.</p> <p>Every batch is a subgraph on the full graph, provided by dgl.dataloading.DataLoader.</p> <p>Parameters:</p> <ul> <li> <p>test: <code>anndata.AnnData</code></p> <p>Test data of shape <code>n_obs</code> \u00d7 <code>n_vars</code>. Rows correspond to cells and columns to genes.</p> </li> <li> <p>image: <code>numpy.ndarray</code></p> <p>H&amp;E image of test data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>result: <code>pandas.DataFrame</code></p> <p>Results of outlier detection. <code>result['cell_idx']</code> contains <code>test.obs_names</code>, and <code>result['score']</code> contains the anomaly scores of every observation.</p> </li> </ul> <p>Warning</p> <ul> <li>fit must be run before predict.</li> <li><code>train</code> and <code>test</code> should have the same genes.</li> <li><code>train_image</code> and <code>test_image</code> are required. And the position of every spot on image should contain in <code>train.obsm['spatial']</code> and <code>test.obsm['spatial']</code>.</li> <li>Default configuration is based on <code>pretrain=True</code>, which means fine-tuning ODBC-GAN. If <code>pretrain=False</code>, a set of new parameters is necessary.</li> </ul>"},{"location":"API/Outlier/outlier_detect/","title":"og.outlier_detect","text":"<p>Function</p> <p>og.outlier_detect(train, test, train_image=None, test_image=None, mode='SC', **kwargs)</p> <p>Detect outlier cells in SC mode, and outlier spots in SRT mode.</p> <p>Integrate two main classes og.detect.Detect_SC and og.detect.Detect_SRT to implement outlier detection.</p> <p>Hyperparameters (<code>n_epochs</code>, <code>learning_rate</code>, and etc.) are allowed for changing the default configuration. Detailed hyperparameter description can be see in og.detect.Detect_SC and og.detect.Detect_SRT.</p> <p>Parameters:</p> <ul> <li> <p>train: <code>anndata.AnnData</code></p> <p>Train data of shape <code>n_obs</code> \u00d7 <code>n_vars</code>. Rows correspond to cells and columns to genes.</p> </li> <li> <p>test: <code>anndata.AnnData</code></p> <p>Test data of shape <code>n_obs</code> \u00d7 <code>n_vars</code>. Rows correspond to cells and columns to genes.</p> </li> <li> <p>train_image: <code>Optional[numpy.ndarray]</code> (default: <code>None</code>)</p> <p>H&amp;E image of train data. Required for SRT mode.</p> </li> <li> <p>test_image: <code>Optional[numpy.ndarray]</code> (default: <code>None</code>)</p> <p>H&amp;E image of test data. Required for SRT mode.</p> </li> <li> <p>mode: <code>Literal['SC', 'SRT']</code> (default: <code>'SC'</code>)</p> <p>Working mode of ODBC-GAN. </p> </li> </ul> <p>Returns:</p> <ul> <li> <p>result: <code>pandas.DataFrame</code></p> <p>Results of outlier detection. <code>result['cell_idx']</code> contains <code>test.obs_names</code>, and <code>result['score']</code> contains the anomaly scores of every observation.  </p> </li> </ul> <p>Warning</p> <ul> <li>When testing on different datasets, it's necessary to tune hyperparameters on the default configuration for better performance results.</li> <li><code>train</code> and <code>test</code> should have the same genes.</li> <li>In SRT mode, <code>train_image</code> and <code>test_image</code> are required. And the position of every spot on image should contain in <code>train.obsm['spatial']</code> and <code>test.obsm['spatial']</code>.</li> </ul> <p>Example: <pre><code>import scanpy as sc\nimport ODBCGAN as og\ntrain = sc.read('train.h5ad')\ntest = sc.read('test.h5ad')\n# use default config\nog.outlier_detect(train, test, mode='SC')\n# tune hyperparameters\nog.outlier_detect(train, test, mode='SC', learning_rate=1e-4)\n</code></pre></p>"},{"location":"API/Pretrain/Pretrain_SC/","title":"og._pretrain.Pretrain_SC","text":"<p>Function</p> <p>Pretrain_SC(train, n_epochs=50, batch_size=32, learning_rate=0.0005, GPU=True, verbose=True, log_interval=10, random_state=None, norm_type='Batch')</p> <p>Pretrain gene generator in SC mode by mini-batch.</p> <p>Parameters:</p> <ul> <li> <p>train: <code>anndata.AnnData</code></p> <p>Train data of shape <code>n_obs</code> \u00d7 <code>n_vars</code>. Rows correspond to cells and columns to genes.</p> </li> <li> <p>n_epochs: <code>int</code> (default: <code>50</code>)</p> <p>Number of train epochs.</p> </li> <li> <p>batch_size: <code>int</code> (default: <code>32</code>)</p> <p>Batch size of train data.</p> </li> <li> <p>learning_rate: <code>float</code> (default: <code>0.0005</code>)</p> <p>Learning rate for Adam optim.</p> </li> <li> <p>GPU: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, run ODBC-GAN on GPU.</p> </li> <li> <p>verbose: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, print detailed information of every epoch.</p> </li> <li> <p>log_interval: <code>int</code> (default: <code>10</code>)</p> <p>Interval of epochs between two adjacent printed information.</p> </li> <li> <p>random_state: <code>Optional[int]</code> (default: <code>None</code>)</p> <p>Random state to control all kinds of random seeds.</p> </li> <li> <p>norm_type: <code>Literal['Batch', 'Instance']</code> (default: <code>Batch</code>)</p> <p>Type of normalization layers. If <code>'Batch'</code>, batch normalization. If <code>'Instance'</code>, instance normalization.</p> </li> </ul> <p>Note</p> <ul> <li><code>norm_type='Instance'</code> is suitable for batch correction task.</li> <li><code>norm_type='Batch'</code> is suitable for other tasks.</li> </ul>"},{"location":"API/Pretrain/Pretrain_SRT/","title":"og._pretrain.Pretrain_SRT","text":"<p>Function</p> <p>Pretrain_SRT(adata, image, n_epochs=200, batch_size=128, learning_rate=1e-5, GPU=True, verbose=True, log_interval=10, random_state=None, norm_type='Batch')</p> <p>Pretrain gene generator in SRT mode by mini-batch.</p> <p>Parameters:</p> <ul> <li> <p>adata: <code>anndata.AnnData</code></p> <p>Train data of shape <code>n_obs</code> \u00d7 <code>n_vars</code>. Rows correspond to cells and columns to genes.</p> </li> <li> <p>image: <code>numpy.ndarray</code></p> <p>H&amp;E image of train data.</p> </li> <li> <p>n_epochs: <code>int</code> (default: <code>200</code>)</p> <p>Number of train epochs.</p> </li> <li> <p>batch_size: <code>int</code> (default: <code>128</code>)</p> <p>Batch size of train data.</p> </li> <li> <p>learning_rate: <code>float</code> (default: <code>1e-5</code>)</p> <p>Learning rate for Adam optim.</p> </li> <li> <p>GPU: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, run ODBC-GAN on GPU.</p> </li> <li> <p>verbose: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, print detailed information of every epoch.</p> </li> <li> <p>log_interval: <code>int</code> (default: <code>10</code>)</p> <p>Interval of epochs between two adjacent printed information.</p> </li> <li> <p>random_state: <code>Optional[int]</code> (default: <code>None</code>)</p> <p>Random state to control all kinds of random seeds.</p> </li> <li> <p>norm_type: <code>Literal['Batch', 'Instance']</code> (default: <code>'Batch'</code>)</p> <p>Type of normalization layers. If <code>'Batch'</code>, batch normalization. If <code>'Instance'</code>, instance normalization.</p> </li> </ul> <p>Note</p> <ul> <li><code>norm_type='Instance'</code> is suitable for batch correction task.</li> <li><code>norm_type='Batch'</code> is suitable for other tasks.</li> <li>Implement mini-batch train by og._dataset.Build_graph.</li> </ul>"},{"location":"API/Pretrain/Pretrain_img/","title":"og._pretrain.Pretrain_img","text":"<p>Function</p> <p>Pretrain_SRT(adata, image, n_epochs=200, batch_size=128, patch_size=48, learning_rate=1e-5, GPU=True, verbose=True, log_interval=10, random_state=None)</p> <p>Pretrain image generator in SRT mode by mini-batch.</p> <p>Parameters:</p> <ul> <li> <p>adata: <code>Union[anndata.AnnData, List[anndata.AnnData]]</code></p> <p>Input adata or list of input adata. Every adata has the same genes.</p> </li> <li> <p>image: <code>Union[numpy.ndarray, List[numpy.ndarray]]</code></p> <p>Input H&amp;E image or list of input H&amp;E images.</p> </li> <li> <p>n_epochs: <code>int</code> (default: <code>200</code>)</p> <p>Number of train epochs.</p> </li> <li> <p>batch_size: <code>int</code> (default: <code>128</code>)</p> <p>Batch size of train data.</p> </li> <li> <p>patch_size: <code>int</code> (default: <code>48</code>)</p> <p>Side length of every patch.</p> </li> <li> <p>learning_rate: <code>float</code> (default: <code>1e-5</code>)</p> <p>Learning rate for Adam optim.</p> </li> <li> <p>GPU: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, run ODBC-GAN on GPU.</p> </li> <li> <p>verbose: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, print detailed information of every epoch.</p> </li> <li> <p>log_interval: <code>int</code> (default: <code>10</code>)</p> <p>Interval of epochs between two adjacent printed information.</p> </li> <li> <p>random_state: <code>Optional[int]</code> (default: <code>None</code>)</p> <p>Random state to control all kinds of random seeds.</p> </li> </ul> <p>Note</p> <ul> <li>Image generator pretrain is a more difficult task than gene generator pretrain. It is necessary to train the network by entering multiple images.</li> <li>Implement mini-batch train by og._dataset.Build_graph or og._dataset.Build_multi_graph.</li> </ul>"},{"location":"API/Pretrain/Pretrain_multi/","title":"og._pretrain.Pretrain_multi","text":"<p>Function</p> <p>Pretrain_SRT(adata, image, n_epochs=200, batch_size=128, patch_size=48, learning_rate=1e-5, GPU=True, verbose=True, log_interval=10, random_state=None)</p> <p>Pretrain transformer fusion block in SRT mode by mini-batch.</p> <p>Parameters:</p> <ul> <li> <p>adata: <code>Union[anndata.AnnData, List[anndata.AnnData]]</code></p> <p>Input adata or list of input adata. Every adata has the same genes.</p> </li> <li> <p>image: <code>Union[numpy.ndarray, List[numpy.ndarray]]</code></p> <p>Input H&amp;E image or list of input H&amp;E images.</p> </li> <li> <p>n_epochs: <code>int</code> (default: <code>200</code>)</p> <p>Number of train epochs.</p> </li> <li> <p>batch_size: <code>int</code> (default: <code>128</code>)</p> <p>Batch size of train data.</p> </li> <li> <p>patch_size: <code>int</code> (default: <code>48</code>)</p> <p>Side length of every patch.</p> </li> <li> <p>learning_rate: <code>float</code> (default: <code>1e-5</code>)</p> <p>Learning rate for Adam optim.</p> </li> <li> <p>GPU: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, run ODBC-GAN on GPU.</p> </li> <li> <p>verbose: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, print detailed information of every epoch.</p> </li> <li> <p>log_interval: <code>int</code> (default: <code>10</code>)</p> <p>Interval of epochs between two adjacent printed information.</p> </li> <li> <p>random_state: <code>Optional[int]</code> (default: <code>None</code>)</p> <p>Random state to control all kinds of random seeds.</p> </li> </ul> <p>Note</p> <p>Implement mini-batch train by og._dataset.Build_graph or og._dataset.Build_multi_graph.</p> <p>Warning</p> <p>Pretrain weight of gene generator and image generator will be loaded. Make sure the pretrain weight exists.</p>"},{"location":"API/Subtype/Classify_SC/","title":"og.detect.Classify_SC","text":"<p>Class</p> <p>og.detect.Classify_SC(n_subtypes, n_epochs=10, learning_rate=1e-6, weight_decay=0, alpha=1, pretrain=True, GPU=True, verbose=True, log_interval=1, random_state=100)</p> <p>Detect outlier cell subtypes with gene expression as SC mode of ODBC-GAN.</p> <p>og.detect.Classify_SC has one important function fit. This class has been integrated in og.subtype_detect as SC mode.</p> <p>Parameters:</p> <ul> <li> <p>n_subtypes: <code>Union[int, Literal['auto']]</code></p> <p>Number of outlier subtypes. If <code>n_subtypes='auto'</code>, ODBC-GAN will automatically determine the number of subtypes.</p> </li> <li> <p>n_epochs: <code>int</code> (default: <code>10</code>)</p> <p>Number of train epochs.</p> </li> <li> <p>learning_rate: <code>float</code> (default: <code>1e-6</code>)</p> <p>Learning rate for Adam optim.</p> </li> <li> <p>weight_decay: <code>float</code> (default: <code>0</code>)</p> <p>Weight decay for Adam optim.</p> </li> <li> <p>alpha: <code>int</code> (default: <code>1</code>)</p> <p>Hyperparameter of DESC loss.</p> </li> <li> <p>pretrain: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, load pretrained weight for ODBC-GAN.</p> </li> <li> <p>GPU: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, run ODBC-GAN on GPU.</p> </li> <li> <p>verbose: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, print detailed information of every epoch.</p> </li> <li> <p>log_interval: <code>int</code> (default: <code>1</code>)</p> <p>Interval of epochs between two adjacent printed information.</p> </li> <li> <p>random_state: <code>Optional[int]</code> (default: <code>100</code>)</p> <p>Random state to control all kinds of random seeds.</p> </li> </ul> <p>Function of og.detect.Classify_SC</p> <p>fit(z, res)</p> <p>Detect subtypes of outlier cells via deep clustering.</p> <p>Parameters:</p> <ul> <li> <p>z: <code>numpy.ndarray</code></p> <p>Embedding of gene expression vector.</p> </li> <li> <p>res: <code>numpy.ndarray</code></p> <p>Residual loss of gene expression vector.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>pred: <code>numpy.ndarray</code></p> <p>Predict subtype label of every outlier.</p> </li> </ul> <p>Warning</p> <ul> <li><code>train</code> and <code>outlier</code> should have the same genes.</li> <li><code>n_subtypes=None</code> is suitable, if and only if the number of subtypes is unknown in advance.</li> <li>If set <code>n_epochs</code> very large, consider setting <code>weight_decay &gt; 0</code>.</li> </ul>"},{"location":"API/Subtype/Classify_SRT/","title":"og.detect.Classify_SRT","text":"<p>Class</p> <p>og.detect.Classify_SRT(n_subtypes, n_epochs=10, learning_rate=1e-6, weight_decay=0, alpha=1, pretrain=True, GPU=True, verbose=True, log_interval=1, random_state=100, patch_size=48)</p> <p>Detect outlier spot subtypes with gene expression, position and slice image as SRT mode of ODBC-GAN.</p> <p>og.detect.Classify_SRT has one important function fit. This class has been integrated in og.subtype_detect as SRT mode.</p> <p>Parameters:</p> <ul> <li> <p>n_subtypes: <code>Union[int, Literal['auto']]</code></p> <p>Number of outlier subtypes. If <code>n_subtypes='auto'</code>, ODBC-GAN will automatically determine the number of subtypes.</p> </li> <li> <p>n_epochs: <code>int</code> (default: <code>10</code>)</p> <p>Number of train epochs.</p> </li> <li> <p>learning_rate: <code>float</code> (default: <code>1e-6</code>)</p> <p>Learning rate for Adam optim.</p> </li> <li> <p>weight_decay: <code>float</code> (default: <code>0</code>)</p> <p>Weight decay for Adam optim.</p> </li> <li> <p>alpha: <code>int</code> (default: <code>1</code>)</p> <p>Hyperparameter of DESC loss.</p> </li> <li> <p>pretrain: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, load pretrained weight for ODBC-GAN.</p> </li> <li> <p>GPU: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, run ODBC-GAN on GPU.</p> </li> <li> <p>verbose: <code>bool</code> (default: <code>True</code>)</p> <p>If <code>True</code>, print detailed information of every epoch.</p> </li> <li> <p>log_interval: <code>int</code> (default: <code>1</code>)</p> <p>Interval of epochs between two adjacent printed information.</p> </li> <li> <p>random_state: <code>Optional[int]</code> (default: <code>100</code>)</p> <p>Random state to control all kinds of random seeds.</p> </li> <li> <p>patch_size: <code>int</code> (default: <code>48</code>)</p> <p>Side length of every patch.</p> </li> </ul> <p>Function of og.detect.Classify_SRT</p> <p>fit(z_x, res_x, z_img, res_img)</p> <p>Detect subtypes of outlier spots via deep clustering.</p> <p>Parameters:</p> <ul> <li> <p>z_x: <code>numpy.ndarray</code></p> <p>Embedding of gene expression vector.</p> </li> <li> <p>res_x: <code>numpy.ndarray</code></p> <p>Residual loss of gene expression vector.</p> </li> <li> <p>z_img: <code>numpy.ndarray</code></p> <p>Embedding of image patch.</p> </li> <li> <p>res_img: <code>numpy.ndarray</code></p> <p>Residual loss of image patch.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>pred: <code>numpy.ndarray</code></p> <p>Predict subtype label of every outlier.</p> </li> </ul> <p>Warning</p> <ul> <li><code>train</code> and <code>outlier</code> should have the same genes.</li> <li><code>n_subtypes=None</code> is suitable, if and only if the number of subtypes is unknown in advance.</li> <li>If set <code>n_epochs</code> very large, consider setting <code>weight_decay &gt; 0</code>.</li> <li><code>train_image</code> and <code>test_image</code> are required. And the position of every spot on image should contain in <code>train.obsm['spatial']</code> and <code>test.obsm['spatial']</code>.</li> </ul>"},{"location":"API/Subtype/subtype_detect/","title":"og.subtype_detect","text":"<p>Function</p> <p>og.subtype_detect(train, outlier, n_subtypes, train_image=None, outlier_image=None, z_x=None, res_x=None, z_img=None, res_img=None, mode='SC', detect_para={}, **kwargs)</p> <p>Detect outlier cell subtypes in SC mode, and outlier spot subtypes in SRT mode.</p> <p>Integrate two main classes og.detect.Classify_SC and og.detect.Classify_SRT to implement outlier subtype detection.</p> <p>Hyperparameters (<code>n_epochs</code>, <code>learning_rate</code>, and etc.) are allowed for changing the default configuration. Detailed hyperparameter description can be see in og.detect.Classify_SC and og.detect.Classify_SRT.</p> <p>og.subtype_detect implements subtype detection via deep clustering integrated the embedding and residual loss of every outlier observation.</p> <p>Parameters:</p> <ul> <li> <p>train: <code>anndata.AnnData</code></p> <p>Train data of shape <code>n_obs</code> \u00d7 <code>n_vars</code>. Rows correspond to cells and columns to genes. Aim to train a better model for providing latent embedding presentation.</p> </li> <li> <p>outlier: <code>anndata.AnnData</code></p> <p>Outlier data of shape <code>n_obs</code> \u00d7 <code>n_vars</code>. Rows correspond to cells and columns to genes. Aim to generate latent embedding vectors used for deep clustering.</p> </li> <li> <p>n_subtypes: <code>Union[int, Literal['auto']]</code></p> <p>Number of outlier subtypes. If <code>n_subtypes='auto'</code>, ODBC-GAN will automatically determine the number of subtypes.</p> </li> <li> <p>train_image: <code>Optional[numpy.ndarray]</code> (default: <code>None</code>)</p> <p>H&amp;E image of train data. Required for SRT mode.</p> </li> <li> <p>outlier_image: <code>Optional[numpy.ndarray]</code> (default: <code>None</code>)</p> <p>H&amp;E image of outlier data. Required for SRT mode.</p> </li> <li> <p>z_x: <code>Optional[numpy.ndarray]</code> (default: <code>None</code>)</p> <p>Embedding of gene expression vector. If <code>z_x is None</code>, <code>outlier.X</code> will be used to generate embedding.</p> </li> <li> <p>res_x: <code>Optional[numpy.ndarray]</code> (default: <code>None</code>)</p> <p>Residual loss of gene expression vector. If <code>res_x is None</code>, <code>outlier.X</code> will be used to generate residual loss.</p> </li> <li> <p>z_img: <code>Optional[numpy.ndarray]</code> (default: <code>None</code>)</p> <p>Embedding of image patch. If <code>z_img is None</code>, <code>outlier_image</code> will be used to generate embedding.</p> </li> <li> <p>res_img: <code>Optional[numpy.ndarray]</code> (default: <code>None</code>)</p> <p>Residual loss of image patch. If <code>z_img is None</code>, <code>outlier_image</code> will be used to generate residual loss.</p> </li> <li> <p>mode: <code>Literal['SC', 'SRT']</code> (default: <code>'SC'</code>)</p> <p>Working mode of ODBC-GAN. </p> </li> <li> <p>detect_para: <code>Dict</code> (default: <code>{}</code>)</p> <p>Hyperparameters for og.outlier_detect.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>pred: <code>numpy.ndarray</code></p> <p>Predict subtype label of every outlier.</p> </li> </ul> <p>Note</p> <ul> <li>Call og.outlier_detect to generate embedding and residual loss.</li> <li>If both of embedding and residual loss aren't <code>None</code>, they will be straightforward used for subtype detection with ignoring <code>outlier</code> and <code>outlier_image</code>.</li> <li><code>detect_para</code> can tuning og.outlier_detect for better latent embedding presentation.</li> </ul> <p>Warning</p> <ul> <li><code>train</code> and <code>outlier</code> should have the same genes.</li> <li>In SRT mode, <code>train_image</code> and <code>outlier_image</code> are required. And the position of every spot on image should contain in <code>train.obsm['spatial']</code> and <code>outlier.obsm['spatial']</code>.</li> <li><code>n_subtypes=None</code> is suitable, if and only if the number of subtypes is unknown in advance.</li> <li>Run og.outlier_detect to find out outliers at first, and find the best a set of hyperparameters. Then, <code>detect_para</code> stores these hyperparameters, og.subtype_detect will detect outlier subtypes.</li> </ul> <p>Example: <pre><code>import scanpy as sc\nimport ODBCGAN as og\ntrain = sc.read('train.h5ad')\ntest = sc.read('outlier.h5ad')\n# use default config\nog.subtype_detect(train, outlier, n_subtypes=3, mode='SC')\n# tune hyperparameters of og.subtype_detect\nog.subtype_detect(train, outlier, n_subtypes=3, mode='SC', learning_rate=1e-4)\n# tune hyperparameters of og.outlier_detect\nparams = {'learning_rate': 1e-4}\nog.subtype_detect(train, outlier, n_subtypes=3, mode='SC', detect_para=params)\n</code></pre></p>"}]}